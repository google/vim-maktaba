*maktaba.txt*	Consistent Vimscript
Google                                                     *Maktaba* *maktaba*

==============================================================================
CONTENTS                                                    *maktaba-contents*
  1. Introduction..............................................|maktaba-intro|
  2. Version.................................................|maktaba-version|
  3. Dictionaries..............................................|maktaba-dicts|
  4. Functions.............................................|maktaba-functions|
  5. Error Handling.......................................|maktaba-exceptions|

==============================================================================
INTRODUCTION                                                   *maktaba-intro*

A vimscript library that hides the worst parts of vimscript and helps you
provide consistent plugins.

Maktaba is a framework for writing well-behaved, easily-configurable plugins.
It supplies conventions to keep plugins consistent, along with a number of
tools and utilities for plugin authors.

Maktaba introduces a concept of a |maktaba.Flag| for configuration, and
recommends users install a configuration plugin like |Glaive|, or a plugin
manager with configuration support, to manage plugin flags.

Also included are a univesal logging framework, error handling utilities, and
a number of tools that make writing vimscript both safer and easier.

==============================================================================
VERSION                                                      *maktaba-version*

Maktaba uses semantic versioning (see http://semver.org). A version string
contains a major number, a minor number, and a patch number, dot-separated.

The patch number will be bumped for patches, bug fixes, internal cleanup, and
for any change that does not add or remove functions. New optional arguments
may be added to functions by patches.

The minor number will be bumped every time new functionality is added.
Functionality may become deprecated when a minor number bumps. Deprecated
functionality will remain available for at least two minor numbers. For at
least one minor number, deprecation warnings will be documented and silently
logged. For at least one minor number, deprecation warnings will be loud.

Major number bumps indicate sweeping (often backwards-incompatible) changes.

Use |maktaba#IsAtLeastVersion| to check whether this version of maktaba has
passed a given version number.

==============================================================================
DICTIONARIES                                                   *maktaba-dicts*

                                                                *maktaba.Enum*
An enumeration object. It has fields for each name in the enumeration. Each
name is attached to a unique value. Names are in all caps. Example:
>
  let g:animals = maktaba#enum#Create(['DUCK', 'PIG', 'COW'])
  echomsg g:animals.PIG      " This will echo 1.
  echomsg g:animals.COW      " This will echo 2
  echomsg g:animals.Name(0)  " This will echo DUCK.
  echomsg g:animals.Names()  " This will echo ['DUCK', 'PIG', 'COW'].
<

Enum.Name({value})                                               *Enum.Name()*
  Gets the name associated with {value}.
  Throws ERROR(NotFound) if no such name exists on the enum.

Enum.Names()                                                    *Enum.Names()*
  Gets all names on the enum, in value order.

Enum.Value({name})                                              *Enum.Value()*
  Gets the value of the enum at {name}.
  Throws ERROR(NotFound) if no such name exists on the enum.

Enum.Values()                                                  *Enum.Values()*
  Gets all values on the enum, in order.

                                                                *maktaba.Flag*
The maktaba flag object. Exposes functions that operate on an individual
maktaba flag.

Flag.Get([foci])                                                  *Flag.Get()*
  Gets the value of the flag. You may give [foci] to focus on one particular
  part of the flag. For example:
>
    s:plugin.flags.complex.Get(['key', 3])
<
  is equivalent to
>
    s:plugin.flags.complex.Get()['key'][3]
<
  with the difference that the former throws BadValue errors and the latter
  throws E716.

  Flag values are locked. If you need to do complex manipulation on a flag
  value, you must copy it and commit the copied value using |Flag.Set|.
  Throws ERROR(BadValue) if [foci] are invalid.

Flag.GetCopy([foci])                                          *Flag.GetCopy()*
  Gets a deep copy of the value of the flag. You may give [foci] to focus on
  one particular part of the flag. The following are equivalent:
>
    deepcopy(flag.Get())
    flag.GetCopy()
<
  This function is convenient if you need to modify a flag, because flag
  values are locked. Remember that if you change the copy the flag itself
  won't change until you call |Flag.Set|.
  Throws ERROR(BadValue) if [foci] are invalid.

Flag.Set({value}, [foci])                                         *Flag.Set()*
  Sets the flag to {value}. If [foci] are given, they target a specific part
  of a (complex) flag to be set. For example,
>
    call s:plugin.flags.complexflag.Set('leaf', ['a', 0, 'b'])
<
  will set value['a'][0]['b'] to 'leaf'.
  Throws ERROR(BadValue) when an invalid focus is requested.

Flag.AddCallback({callback})                              *Flag.AddCallback()*
  Registers {callback}. It must refer to a function. The function must take
  one argument: the value of the flag. {callback} will be fired immediately
  with the current value of the flag. It will be fired again every time the
  flag changes.

  Callbacks are fired AFTER translation occurs. Callbacks are fired in order
  of their registration.

  This function returns a function which, when applied, unregisters
  {callback}. Hold on to it if you expect you'll need to remove {callback}.
  Throws ERROR(BadValue) if there's already a callback registered under that
  name.

Flag.Callback()                                              *Flag.Callback()*
  Fires all callbacks in order.

Flag.AddTranslator({translator})                        *Flag.AddTranslator()*
  Registers {translator}. {translator} must refer to a function that takes a
  single argument (the value of the flag). {translator} must return a value
  which will become the new value of the flag.

  {translator} will be applied to the current value of the flag immediately,
  and then all registered callbacks will be fired. Thereafter, translators
  will be run every time the flag changes. Translators are fired in order of
  their registration. Callbacks are fired AFTER translation occurs.

  This function returns a function which, when called, unregisters
  {translator}. Hold on to it if you expect you'll need to remove
  {translator}.
  Throws ERROR(BadValue) if there's already a translator registered under that
  name.

Flag.Translate({value})                                     *Flag.Translate()*
  Returns the value that the flag will have after being set to {value} (after
  running {value} through all registered translators).

                                                              *maktaba.Logger*
Interface for a plugin to send log messages to maktaba.

Logger.Debug({message}, [args...])                            *Logger.Debug()*
  Logs a {message} with [args...] at DEBUG level.

Logger.Info({message}, [args...])                              *Logger.Info()*
  Logs a {message} with [args...] at INFO level.

Logger.Warn({message}, [args...])                              *Logger.Warn()*
  Logs a {message} with [args...] at WARN level.

Logger.Error({message}, [args...])                            *Logger.Error()*
  Logs a {message} with [args...] at ERROR level.

Logger.Severe({message}, [args...])                          *Logger.Severe()*
  Logs a {message} with [args...] at SEVERE level.

                                                              *maktaba.Plugin*
The maktaba plugin object. Exposes functions that operate on the plugin
itself.

Plugin.Load([file], [optional])                                *Plugin.Load()*
  If [file] is given, the plugin file plugin/<file>.vim will be sourced. An
  error will  be thrown if [file] does not exist unless [optional] is set. If
  [file] is omitted, then all plugin files that have not yet been sourced will
  be sourced. [file] may also be a list of filenames to source.
  [optional] is 0 if omitted.
  Throws ERROR(NotFound) if [file] is given but is not found.

Plugin.GenerateHelpTags()                          *Plugin.GenerateHelpTags()*
  Generates help tags for the plugin. Returns 0 if there are no help tags.
  Returns 1 if helptags are generated successfully.
  Throws ERROR(Impossible) if help tags cannot be generated.

Plugin.HasDir({dir})                                         *Plugin.HasDir()*
  Tests whether the plugin has {dir}, either as a direct subdirectory or as a
  subirectory of the after/ directory. Cached for performance, so new paths
  will not be discovered if they're added to the plugin after the first check.

Plugin.HasFiletypeData()                            *Plugin.HasFiletypeData()*
  Tests wheter a plugin has a filetype-active directory (ftdetect, ftplugin,
  indent, or syntax).

Plugin.AddonInfo()                                        *Plugin.AddonInfo()*
  Gets plugin metadata from plugin's addon-info.json file, if present.
  Otherwise, returns an empty dict.
  Throws ERROR(BadValue) if addon-info.json isn't valid JSON.

Plugin.Flag({flag}, [value])                                   *Plugin.Flag()*
  Gets or sets {flag}. If [value] is given, {flag} is set to [value].
  Otherwise, the value of {flag} is returned. If {flag} does not exist, the
  plugin flags file will be sourced. The following are equivalent:
>
    maktaba#plugin#Get('myplugin').Flag('foo')
    maktaba#plugin#Get('myplugin').flags.foo.Get()
<
  As are these:
>
    maktaba#plugin#Get('myplugin').Flag('foo', 'bar')
    maktaba#plugin#Get('myplugin').flags.foo.Set('bar')
<

  You may access a portion of a flag (a specific value in a dict flag, or a
  specific item in a list flag) using a fairly natural square bracket syntax:
>
    maktaba#plugin#Get('myplugin').Flag('plugin[autocmds]', 1)
<
  This is equivalent to:
>
    maktaba#plugin#Get('myplugin').flags.plugin.Get()['autocmds'] = 1
<
  This syntax can be chained:
>
    maktaba#plugin#Get('myplugin').Flag('complex[key][0]')
<
  See |maktaba#setting#ParseHandle()| for details.
  Throws ERROR(NotFound) if {flag} does not exist.
  Throws ERROR(BadValue) if {flag} is an invalid flag name.

Plugin.MapPrefix({letter}, [throw])                       *Plugin.MapPrefix()*
  Returns the user's desired map prefix for the plugin. If the user has not
  specified a map prefix, <leader>{letter} will be returned.

  If the user's map prefix is invalid, an error message will be PRINTED, not
  thrown. This allows plugin authors to call this function without worrying
  about barfing up a stack trace if the user config is bad. You can set the
  [throw] argument to make this function throw errors instead of printing
  them, if you plan to catch them explicitly.

  Mappings should  be defined in the plugin/mappings.vim file. The user
  configures their map prefix preferences via the flag that controls that
  file.
  [throw] is 0 if omitted.
  Throws ERROR(NotFound) if plugin/mappings.vim does not exist.
  Throws ERROR(BadValue) if the map prefix is invalid and [throw] is set.
  Throws ERROR(Unknown) if mappings have been disabled.

Plugin.IsLibrary()                                        *Plugin.IsLibrary()*
  Checks that this plugin is a library plugin. In order to be a library
  plugin, the plugin must contain an autoload/ directory and must not contain
  ftplugin/, ftdetect/, syntax/, indent/, nor instant/ directories. If it
  contains a plugin/ directory, that directory must contain only a flags.vim
  file.

                                                             *maktaba.Setting*
Parses {text} into a setting object. The setting object can be applied to a
plugin to affect the plugin flags as described in {text}. Setting syntax is as
follows:

A setting consists of four parts:
  1. Optional unary operator
  2. Flag handle
  3. Optional binary operator (not valid with unary operator)
  4. Flag value (must follow binary operator)

Valid unary operators are ! and ~. The former sets flags to zero, the latter
inverts integer flags (0 becomes 1, everything else becomes 0).

Flag handles consist of a flag name and optionally a number of foci, see
|maktaba#setting#Handle()| for details.

Valid binary operators are = += -= ^= $= and `=.
  * = sets a flag directly.
  * += adds to numbers, appends to lists and strings, and extends
    dictionaries.
  * -= subtracts from numbers and removes from lists and dictionaries.
  * ^= prepends to lists and strings.
  * $= appends to lists and strings.
  * `= sets a flag to the result of appling the function named by the value.

Values are parsed as follows:
  1. Values in single or double quotes are parsed as strings.
  2. Anything in backticks is evaluated (double backticks escape a backtick).
  3. A value containing only numeric characters is parsed as an integer.
  4. Numeric values with one internal dot are parsed as floats (like 0.5).
  5. Any simple string [a-zA-Z0-9_-] is parsed as a string.
  6. A comma-separated series of simple strings & numbers is parsed as a list.
  7. A comma-separated series of key:value pairs (simple strings & numbers) is
    parsed as a dictionary.

If no operator (unary or binary) is given, the setting will set that handle to
1 when applied. If the '=' operator is used, but no value is given, the flag
will be emptied (see |maktaba#value#EmptyValue()|).

Setting.Apply({plugin})                                      *Setting.Apply()*
  Applies the setting to {plugin}. Returns the new value of the affected flag,
  for convenience.
  Throws ERROR(NotFound) if {plugin} does not define the appropriate flag.
  Throws ERROR(WrongType) if the flag is not of a type the setting requires.
  Throws ERROR(BadValue) if the flag has a value innapropriate for the
  setting.

                                                             *maktaba.Syscall*
A maktaba representation of a system call, which is used to configure and
execute a system command.

Syscall.WithCwd({directory})                               *Syscall.WithCwd()*
  Returns a copy of the |maktaba.Syscall| configured to be executed in
  {directory}.
  Throws ERROR(WrongType)
  Throws ERROR(NotFound) if {directory} is invalid.

Syscall.WithStdin({input})                               *Syscall.WithStdin()*
  Configures {input} to be passed via stdin to the command. Only supported for
  |Syscall.Call()|. Calling |Syscall.CallForeground()| on a Syscall with stdin
  specified will cause |ERROR(NotImplemented)| to be thrown.
  Throws ERROR(WrongType)

Syscall.And({cmd})                                             *Syscall.And()*
  Returns a new |maktaba.Syscall| that chains self and {cmd} together with a
  logical AND operation ("&&"). {cmd} may be any valid
  |maktaba#syscall#Create()| argument.
  Throws ERROR(WrongType)

Syscall.Or({cmd})                                               *Syscall.Or()*
  Returns a new |maktaba.Syscall| that chains self and {cmd} together with a
  logical OR operation ("&&"). {cmd} may be any valid
  |maktaba#syscall#Create()| argument.
  Throws ERROR(WrongType)

Syscall.Call([throw_errors])                                  *Syscall.Call()*
  Executes the system call without showing output to the user. If
  [throw_errors] is 1, any exit code from the command will cause a ShellError
  to be thrown. Otherwise, the caller is responsible for checking
  |v:shell_error| and handling error conditions.
  [throw_errors] is 1 if omitted.
  Returns a dictionary with the following fields:
    * stdout: the shell command's entire stdout string, if available.
    * stderr: the shell command's entire stderr string, if available.
  Throws ERROR(WrongType)
  Throws ERROR(ShellError) if the shell command returns an exit code.

Syscall.CallForeground({pause}, [throw_errors])     *Syscall.CallForeground()*
  Executes the system call in the foreground, showing the output to the user.
  If {pause} is 1, output will stay on the screen until the user presses
  Enter. If [throw_errors] is 1, any exit code from the command will cause a
  ShellError to be thrown. Otherwise, the caller is responsible for checking
  |v:shell_error| and handling error conditions.
  [throw_errors] is 1 if omitted.
  Returns a dictionary with the following fields:
    * stdout: the shell command's entire stdout string, if available.
    * stderr: the shell command's entire stderr string, if available.
  Throws ERROR(WrongType)
  Throws ERROR(ShellError) if the shell command returns an exit code.
  Throws ERROR(NotImplemented) if stdin has been specified for this Syscall.

Syscall.GetCommand()                                    *Syscall.GetCommand()*
  Gets the literal command string that would be executed by |Syscall.Call()|
  or |Syscall.CallForeground()|, with words joined and special characters
  escaped.

==============================================================================
FUNCTIONS                                                  *maktaba-functions*

maktaba#Maktaba()                                          *maktaba#Maktaba()*
  Returns a handle to the maktaba plugin object.

maktaba#IsAtLeastVersion({version})               *maktaba#IsAtLeastVersion()*
  Use this function to query against the maktaba version. Returns true if the
  maktaba version is at or past {version}. For example:
>
    maktaba#IsAtLeastVersion('1.0.3')
<
  There is no equivalent function for checking an upper bound. This is
  designed to prevent unsatisfiable dependencies such as one plugin requiring
  <2.0.0 and another requiring >=2.1.0. Enforcing a maximum version is
  discouraged.

maktaba#LateLoad([cycle])                                 *maktaba#LateLoad()*
  This function essentially mimics the vim plugin installation phase. All
  plugins installed by maktaba that have not been sourced will be sourced.
  This will also cycle filetypes (see |maktaba#filetype#Cycle()|) unless
  [cycle] is set to 0.
  [cycle] is 1 if omitted.

maktaba#autocmd#ClearGroup({augroup})           *maktaba#autocmd#ClearGroup()*
  Removes all autocmds in {augroup}, then removes {augroup}.

maktaba#buffer#Overwrite({startline}, {endline}, {lines})
                                                  *maktaba#buffer#Overwrite()*
  Replace the lines from {startline} to {endline} in the current buffer with
  {lines}. {startline} and {endline} are numbers. {endline} is inclusive
  following vim's precedent. {lines} is a list of strings.

  This is not a range function because range functions always move the cursor
  (requiring the caller to manage the cursor explicitly to prevent it), which
  is not good behavior for any library function.

  Use with an empty list to delete a range of lines. Use |append()| to insert
  lines instead of overwriting.
  Throws ERROR(WrongType) if the arguments are invalid.
  Throws ERROR(BadValue) if {startline} is greater than {endline}.

maktaba#buffer#Substitute({pattern}, [replacement], [flags], [firstline],
  [lastline], [usecase], [searchdelimiter])      *maktaba#buffer#Substitute()*
  Performs a configuration-agnostic substitution in the current buffer. For
  the duration of the substitution, 'gdefault' is on, 'ignorecase' is off, and
  'smartcase' is off. These settings are restored after the substitution. The
  e flag is inverted: errors will not be shown unless the e flag is present.
  The cursor does not move. The range is the whole file by default.

  {pattern} The pattern to replace. [replacement] The replacement string.
  [flags] The search flags. See |:s_flags|. "e" and "g" are on by default.
  [firstline] The first line of the replacement range.
  [firstline] is 0 if omitted.
  [lastline] The last line of the replacement range.
  [lastline] is equal to line('$') if omitted.
  [usecase] Whether to honor the user's case sensitivity settings.
  [usecase] is 0 if omitted.
  [searchdelimiter] The search delimiter to use. Must be accepted by |:s|.
  [searchdelimiter] is '/' if omitted.

maktaba#command#GetOutput({command})             *maktaba#command#GetOutput()*
  Runs {command} silently, returns its output as a string.

maktaba#compatibility#Disable()              *maktaba#compatibility#Disable()*
  Turns vi-compatibility mode off and issues a warning if it was on. Plugins
  which use maktaba should call this function after installing maktaba (or
  'set nocompatible' by other means). Maktaba does not support vi
  compatibility; if maktaba is installed without a compatibility check then
  maktaba may die loudly.

maktaba#ensure#IsTrue({condition}, [message], [args...])
                                                     *maktaba#ensure#IsTrue()*
  Checks that {condition} is nonzero. If not, throws Failure with [message],
  formatted with [args...].
  [message] is "No message given." if omitted.
  Throws ERROR(Failure) if {condition} is zero.

maktaba#ensure#IsFalse({condition}, [message], [args...])
                                                    *maktaba#ensure#IsFalse()*
  Checks that {condition} is zero. If not, throws Failure with [message],
  formatted with [args...].
  [message] is "No message given." if omitted.
  Throws ERROR(Failure) if {condition} is nonzero.

maktaba#ensure#IsEqual({value}, {reference})        *maktaba#ensure#IsEqual()*
  Ensures that {value} is equal to {reference}. Returns {value} for
  convenience. Equality is checked using |maktaba#value#IsEqual()|. Note that
  {value} and {reference} MUST share a type: 1.0 does not equal 1! This is
  consistent with the behavior of instant() and count() rather than with the
  behavior of the '==' operator.
  Throws ERROR(WrongType) if {value} is not the same type as {reference}.
  Throws ERROR(BadValue) if {value} does not equal {reference}.

maktaba#ensure#IsIn({value}, {values})                 *maktaba#ensure#IsIn()*
  Ensures that {value} is in {values}. Returns {value} for convenience.
  Throws ERROR(BadValue) if {value} is not contained in {values}

maktaba#ensure#Passes({value}, {predicate})          *maktaba#ensure#Passes()*
  Ensures that {value} passes {predicate}. {predicate} must be something
  callable (see |maktaba#function#Call|), and must take a single argument. It
  should return 1 or 0. On a 1, {value} is returned. On a 0, a BadValue error
  is thrown. Returns {value} for convenience.
  Throws ERROR(BadValue) if {value} does not pass {predicate}.

maktaba#ensure#TypeMatches({value}, {reference})
                                                *maktaba#ensure#TypeMatches()*
  Ensures that {value} has the same type as {reference}. Returns {value} for
  convenience.
  Throws ERROR(WrongType)

maktaba#ensure#TypeMatchesOneOf({value}, {values})
                                           *maktaba#ensure#TypeMatchesOneOf()*
  Ensures that {value} has the same type as one of the elements in {values}.
  Returns {value} for convenience
  Throws ERROR(WrongType)

maktaba#ensure#IsBool({value})                       *maktaba#ensure#IsBool()*
  Ensures that {value} is 0 or 1, returns it for convenience.
  Throws ERROR(BadValue) if {value} is a number but not 0 or 1.
  Throws ERROR(WrongType) if {value} is not a number.

maktaba#ensure#IsNumber({value})                   *maktaba#ensure#IsNumber()*
  Ensures that {value} is a number, returns it for convenience.
  Throws ERROR(WrongType)

maktaba#ensure#IsString({value})                   *maktaba#ensure#IsString()*
  Ensures that {value} is a string, returns it for convenience.
  Throws ERROR(WrongType)

maktaba#ensure#IsFuncref({value})                 *maktaba#ensure#IsFuncref()*
  Ensures that {value} is a funcref, returns it for convenience.
  Throws ERROR(WrongType)

maktaba#ensure#IsList({value})                       *maktaba#ensure#IsList()*
  Ensures that {value} is a list, returns it for convenience.
  Throws ERROR(WrongType)

maktaba#ensure#IsDict({value})                       *maktaba#ensure#IsDict()*
  Ensures that {value} is a dictionary, returns it for convenience.
  Throws ERROR(WrongType)

maktaba#ensure#IsFloat({value})                     *maktaba#ensure#IsFloat()*
  Ensures that {value} is a float, returns it for convenience.
  Throws ERROR(WrongType)

maktaba#ensure#IsNumeric({value})                 *maktaba#ensure#IsNumeric()*
  Ensures that {value} is numeric (float or number), returns it for
  convenience.
  Throws ERROR(WrongType)

maktaba#ensure#IsCollection({value})           *maktaba#ensure#IsCollection()*
  Ensures that {value} is a collection (list or dict), returns it for
  convenience.
  Throws ERROR(WrongType)

maktaba#ensure#IsCallable({value})               *maktaba#ensure#IsCallable()*
  Ensures that {value} is callable (string or funcref). Returns it for
  convenience.  This DOES NOT assert that the function denoted by {value}
  actually exists. It mereley ensures that {value} is the correct TYPE for
  |maktaba#function#Call|.
  Throws ERROR(WrongType) if {value} is not a string, funcref, nor dict.
  Throws ERROR(BadValue) if {value} is a dict but does not appear to be a
  funcdict.

maktaba#ensure#IsEnum({value})                       *maktaba#ensure#IsEnum()*
  Ensures that {value} is a maktaba enum object, returns it for convenience.
  Throws ERROR(WrongType) if {value} is not a dictionary.
  Throws ERROR(BadValue) if {value} does not appear to be a maktaba enum
  object.

maktaba#ensure#Matches({value}, {regex})            *maktaba#ensure#Matches()*
  Ensures that {value} is a string matching {regex}. Case sensitive matching
  is used. Returns {value} for convenience.
  Throws ERROR(WrongType)
  Throws ERROR(BadValue)

maktaba#ensure#PathExists({path})                *maktaba#ensure#PathExists()*
  Ensures {path} exists on the filesystem. Returns {path} for convenience.
  Throws ERROR(NotFound) otherwise.

maktaba#ensure#IsDirectory({path})              *maktaba#ensure#IsDirectory()*
  Ensures {path} is an existing directory. Returns {path} for convenience.
  Throws ERROR(NotFound) if {path} does not exist.
  Throws ERROR(BadValue) if {path} is a file.

maktaba#ensure#IsFile({path})                        *maktaba#ensure#IsFile()*
  Ensures {path} is an existing file. Returns {path} for convenience.
  Throws ERROR(NotFound) if {path} does not exist.
  Throws ERROR(BadValue) if {path} is a directory.

maktaba#ensure#FileReadable({path})            *maktaba#ensure#FileReadable()*
  Ensures {path} is a readable file. Returns {path} for convenience.
  Throws ERROR(NotFound) if {path} does not exist.
  Throws ERROR(BadValue) if {path} is a directory.
  Throws ERROR(NotAuthorized) if {path} cannot be read.

maktaba#ensure#FileWritable({path})            *maktaba#ensure#FileWritable()*
  Ensures {path} is a writable file. Returns {path} for convenience.
  Throws ERROR(NotFound) if {path} does not exist.
  Throws ERROR(BadValue) if {path} is a directory.
  Throws ERROR(NotAuthorized) if {path} cannot be written.

maktaba#ensure#IsAbsolutePath({path})        *maktaba#ensure#IsAbsolutePath()*
  Ensures {path} is an absolute path. Returns {path} for convenience.
  Throws ERROR(BadValue) if {path} is not absolute.

maktaba#ensure#IsRelativePath({path})        *maktaba#ensure#IsRelativePath()*
  Ensures {path} is a relative path. Returns {path} for convenience.
  Throws ERROR(BadValue) if {path} is not relative.

maktaba#enum#Create({names})                           *maktaba#enum#Create()*
  Creates an enum object from {names}. {names} may be a list of names (in
  which case they will be valued 0, 1, etc.) or a dictionary of {name: value}.
  Names and values must be unique. Names must be uppercase. {names} may not be
  empty.

  The resulting object will be a dict with a member for each name. For
  example:
>
    let g:animals = maktaba#enum#Create(['DUCK', 'PIG'])
    echomsg g:animals.PIG  " This will echo 1.
<
  Throws ERROR(BadValue) if {names} is invalid.

maktaba#error#Warn({message}, [args...])                *maktaba#error#Warn()*
  Prints {message} in a red warning bar for the user. {message} will be
  formatted with [args...], as in |printf()|.

maktaba#error#Shout({message}, [args...])              *maktaba#error#Shout()*
  Prints {message} in an angry red error bar for the user. Don't use
  |:echoerr|! It doesn't make that red error bar and it prints out the line in
  the code where the error occured. It's for debugging, not messaging! If
  [args...] are given they will be used to expand {message} as in |printf()|.

maktaba#error#Exception({type}, {message}, {fmtargs})
                                                   *maktaba#error#Exception()*
  Simple function used for making exception functions. This is very similar to
  |maktaba#error#Message()| in that it throws
>
    ERROR({type}): {message}
<
  The only difference is that the {fmtargs} is a required list argument,
  whereas |maktaba#error#Message()| uses varargs. This function exists to make
  it easy to write exception functions without messing with vararg logic. For
  example:
>
    function! maktaba#error#NotFound(message, ...)
      return maktaba#error#Exception('NotFound', a:message, a:000)
    endfunction
<

  {type} must contain only letters, numbers, underscores, and hyphens.
  Throws ERROR(BadValue) if {type} contains invalid characters.

maktaba#error#Message({type}, {message}, [args...])  *maktaba#error#Message()*
  Makes an error message in the Google vimscript error format. The error
  message will look like:
>
    ERROR({type}): {message}
<
  {message} will be formatted with [args...] as in |printf()|.

  {type} must contain only letters, numbers, underscores, and hyphens.
  Throws ERROR(BadValue) if {type} contains invalid characters.

maktaba#error#Split({exception})                       *maktaba#error#Split()*
  Breaks {exception} message into the error type and the error message.
  Returns both (in a list of length 2).
  Throws ERROR(BadValue) if {exception} is not a vim nor maktaba exception.

maktaba#error#Try({func}, [exceptions], [default])       *maktaba#error#Try()*
  Runs {func}. Catches [exceptions] and |maktaba#error#Shout()|s them. Other
  exceptions are allowed to pass through. If an exception is caught and
  shouted, [default] is returned.

  USE THIS FUNCTION WHEN YOU WANT ERRORS TO BE EXPOSED TO THE END USER. Do not
  allow expected exceptions to propagate to the user normally: this will
  result in an ugly and intimidating stack trace. If a function has EXPECTED
  failure modes, and you WANT the error messages to be surfaced to the user
  (without a stack trace), use this function.

  {func} may be any maktaba callable. See |maktaba#function#Create|.

  [exceptions] may either be a regex matched against |v:exception|, or a list
  of Google error names and/or vim error numbers. For example, the following
  are equivalent:
>
    call maktaba#error#Try(g:fn, 'ERROR(BadValue):\|E107:')
    call maktaba#error#Try(g:fn, ['BadValue', 107])
<
  Use '.*' to expose all exceptions.

  [exceptions] is .* if omitted.
  [default] is 0 if omitted.

maktaba#error#TryCommand({command}, [exceptions]) *maktaba#error#TryCommand()*
  Like |maktaba#error#Try()|, but executes {command} instead of calling a
  function.
  [exceptions] is .* if omitted.

maktaba#filetype#IsEnabled()                    *maktaba#filetype#IsEnabled()*
  Returns 1 if filetype detection is enabled in vim, 0 otherwise.

maktaba#filetype#Cycle([reload])                    *maktaba#filetype#Cycle()*
  Enables new filetypes. This function should be called when plugins have been
  loaded after normal plugin load time is completed (in which case
  ftdetect/ftplugin/indent/syntax files would otherwise be ignored). It acts
  as follows:

  If filetype detection is enabled, filetype detection is cycled. This means
    that all ftdetect rules in new plugins will come into effect. ftplugin and
    indent usage are respected: maktaba will neither enable nor disable
    ftplugin/indent functionality.
  If syntax highlighting is on, syntax highlighting will not be re-applied.
    The user must re-edit any existing buffers to get updated highlights.
  If [reload] is set, BufRead autocmds will be refired. This will cause all
    open buffers to undergo the filetype detection phase again, causing
    ftplugin, syntax, and indent rules to be applied to existing buffers.

  [reload] is 0 if omitted.

maktaba#flags#Create({name}, [default])               *maktaba#flags#Create()*
  Creates a |maktaba.Flag| object for a flag named {name}. The flag will be
  initialized to [default].
  [default] is 0 if omitted.

maktaba#function#Create({func}, [arglist], [dict]) *maktaba#function#Create()*
  Creates a funcdict object that can be applied with
  |maktaba#function#Apply()|. When applied, {func} will be applied with
  [arglist], a list of arguments. If {func} is already a funcdict, it will be
  passed the arguments in [arglist] AFTER the arguments that are already
  pending.

  If [dict] is given it must be a dictionary, which will be passed as the
  dictionary context to {func} when applied. (In this case, {func} must be a
  dictionary function.) [dict] may also be the number 0, in which case it will
  be ignored.

  This allows you to create actual closures in vimscript (by storing context
  in a dictionary, see |Dictionary-function|.

  Note that the resulting funcdict can only be used in scopes where {func} can
  be used. For example, if {func} is script-local then the resulting function
  object is also script-local. (Builtin and autoloaded functions are in the
  global scope, so if {func} is builtin or autoloaded then the resulting
  function object can be used anywhere).

  [arglist] is [] if omitted.
  [dict] is 0 if omitted.

maktaba#function#Call({func}, [arglist], [dict])     *maktaba#function#Call()*
  Applies {func} (optionally to [arglist], optionally with [dict] as its
  dictionary context). {func} may be a funcref, a string describing a
  function, or a maktaba funcdict (see |maktaba#function#Create()|).

  If {func} is a funcdict that has arguments pending, [arglist] will be sent
  to the function APPENDED to the pending arguments.

  [dict], if given and non-zero, will override any existing dictionary
  context. Note that if [dict] is given, {func} must describe a dictionary
  function.

  [arglist] is [] if omitted.
  [dict] is 0 if omitted.

maktaba#function#Method({dict}, {method})          *maktaba#function#Method()*
  Creates a funcdict that is {method} on {dict}, with {dict} bound as the
  dictionary context.

  This is usually what users mean when they say something like dict.Method,
  but unfortunately, vimscript 'forgets' the dictionary context when you
  extract a method. Thus, you sometimes have to do things like
>
    call call(dict.Method, [args], dict)
<
  Which is just silly. Using this function, you can do
>
    call maktaba#function#Method(dict, 'Method').Apply(args)
<
  which is a little less repetitive.

  Throws ERROR(NotFound) if {dict} has no such {method}.

maktaba#function#Apply({func}, [args...])           *maktaba#function#Apply()*
  Applies {func} to [args...]. This is like |maktaba#function#Call()|, but
  allows you to pass arguments in naturally rather than wrapping them in a
  list.

  Note that because vimscript functions are limited to 20 arguments, and
  because one argument is spent to specify {func}, this function can only send
  nineteen arguments on. If this is too limiting, use |#Call|.

maktaba#function#WithArgs({func}, [arg...])      *maktaba#function#WithArgs()*
  Given callable {func}, creates a function object that will be called with
  [arg...] when it is applied. If {func} is a funcdict with pending arguments,
  then when {func} is applied [arg...] will be sent to the inner function
  AFTER the existing arguments. For example:
>
    :echomsg maktaba#function#WithArgs('get', ['a', 'b', 'c']).Apply(1)
<
  This will echo b.

  This will always create a new funcdict. {func} will not be modified.

maktaba#function#WithContext({func}, {dict})  *maktaba#function#WithContext()*
  Creates a funcdict that will call {func} with dictionary context {dict} when
  applied.

  This will always create a new funcdict. {func} will not be modified.

maktaba#function#FromExpr({expr}, [arglist], [dict])
                                                 *maktaba#function#FromExpr()*
  Creates a funcdict that evaluates and returns {expr} when applied. {expr}
  may reference numbered arguments (|a:1|, a:2, ... through a:19). {expr}
  itself is available as a:expr. [arglist] will be queued as the initial
  arguments, if given:
>
    :let hello = maktaba#function#FromExpr('a:1 . ", " . a:2', ['Hello'])
    :echomsg hello.Apply('World')
<
  This will echo "Hello, World".

  If [dict] is given then it must be a dictionary, and will be used as the
  dictionary context for the resulting function. In that case, {expr} may also
  make use of |self|.

maktaba#function#Compose({g}, {f})                *maktaba#function#Compose()*
  Creates a composition of {g} and {f}.

  This creates a function object that, when applied, will apply {g} to the
  result of applying {f} to the given arguments.

  Notice that, as per the usual convention, control flow passes RIGHT TO LEFT:
  {g} (the FIRST argument) will be run on the result of {f} (the SECOND
  argument).

  The final result is returned.


maktaba#function#Compose({functions...})
  Composes all of {functions...}, RIGHT to LEFT. For example,
>
    :let HGF = maktaba#function#Compose(H, G, F)
    :call HGF.Apply(x)
<
  computes H(G(F(x))).

maktaba#function#Map({list}, {func})                  *maktaba#function#Map()*
  Replaces each item of {list} with the result of applying {func} to that
  item. This is like |map|, except {func} may be any maktaba callable and
  where a new list is created. Unlike the builtin map() function, {list} WILL
  NOT be modified in place.

  If you really need to modify a list in-place, you can use
>
    map({list}, 'maktaba#function#Call({func}, [v:val])')
<

maktaba#function#Filter({list}, {func})            *maktaba#function#Filter()*
  Applies {func} to each item in {list}, and removes those for which {func}
  returns 0. This is like |filter|, except {func} may be any maktaba callable
  and a new list is created. Unlike the builtin filter() function, {list} WILL
  NOT be modified in place.

  If you really need to filter a list in-place, you can use
>
    filter({list}, 'maktaba#function#Call({func}, [v:val])')
<

maktaba#function#Reduce({list}, {initial}, {func}) *maktaba#function#Reduce()*
  Reduces {list} to a single value, using {initial} and {func}. {func} must be
  a function that takes two values.

  First, {func} is applied to {initial} and the first item in {list}. Then,
  {func} is applied again to the first result and the second item in {list},
  and so on. The final result is returned.

  If {list} is empty, {initial} will be returned.

maktaba#function#Reduce1({list}, {func})          *maktaba#function#Reduce1()*
  Like |maktaba#function#Reduce()|, except {list} must be non-empty. The first
  item of {list} will be used as the initial value, the remainder of {list}
  will be reduced.

  Throws ERROR(BadValue) if {list} is empty.

maktaba#function#Sort({list}, {func})                *maktaba#function#Sort()*
  Sorts {list} IN PLACE, using {func} to determine the order of items in the
  list. {func} must take two arguments and return either 0 (if they are
  equal), 1 (if the first item comes after the second item), or -1 (if the
  second item comes after the first item).

  {list} is returned, for convenience.

  This is like the builtin |sort()| function, except {func} may be any maktaba
  callable.

maktaba#function#Sorted({list}, {func})            *maktaba#function#Sorted()*
  Returns a new list that is a sorted copy of {list}. {func} is used to
  determine the sort order, as in |sort()|.

maktaba#library#Import({library})                   *maktaba#library#Import()*
  Imports {library}.

  NOTICE: You probably want |maktaba#library#Require()| instead. When calling
  this function, YOU ARE EXPECTED TO CATCH ERRORS and format the error
  messages nicely for the user. (See |maktaba#error#Shout|). Otherwise the
  user will see ugly stack traces.

  NOTICE: {library} MUST BE A LIBRARY PLUGIN. It should provide only
  autoloaded functions. It should not provide commands, autocmds, key
  mappings, filetypes, or any other user-impacting functionality.
  maktaba#library#Require is designed to allow plugins to pull in other
  plugins without the user worrying about dependencies, but the user should
  NEVER have weird key mappings / settings changes / etc. appearing due to
  dependencies required by a rogue plugin.

  This function will act as follows:

    1. Check whether {library} has already been installed via
      |maktaba#plugin#Install()|.
    2. Try each installer registered my |maktaba#library#AddInstaller()|, in
      order of registration.

  The maktaba plugin object will be returned.

  Throws ERROR(NotALibrary) if {library} is not a library plugin.
  Throws ERROR(NotFound) if {library} cannot be installed by any installer.

maktaba#library#Require({library})                 *maktaba#library#Require()*
  Requires that {library} be imported. (See |maktaba#library#Import()|).

  Works just like |maktaba#library#Import()|, except errors will be caught and
  printed in a user-friendly manner (shielding the user from ugly stack
  dumps). This function returns 1 on success and 0 on failure. Use this
  instead of |maktaba#library#Import()| when you don't care to grab a handle
  to the imported plugin object (which is usually).

  Throws ERROR(NotALibrary) if {library} describes a non-library plugin.

maktaba#library#AddInstaller({name}, {installer})
                                              *maktaba#library#AddInstaller()*
  Adds a library installer.

  {installer} should be a callable that takes a single argument (the name of a
  library). {installer} must take one two actions.

    1. Return the installed maktaba plugin object (see
      |maktaba#plugin#Install()|.
    2. Throw a NotFound error if the plugin cannot be found.

  {installer} need not worry about verifying that the installed plugin is
  actually a library plugin, that is handled by maktaba.

  This function returns a function which, when applied, unregisters
  {installer}. Hold on to it if you expect you'll need to remove {installer}.

  Throws ERROR(BadValue) if there's already an installer registered under
  {name}.

maktaba#library#RemoveInstaller({name})    *maktaba#library#RemoveInstaller()*
  Removes the library installer named {name}.
  Throws ERROR(NotFound) if no such installer exists.

maktaba#list#RemoveItem({list}, {item})            *maktaba#list#RemoveItem()*
  Removes the first instance of {item} from {list}. {list} is returned for
  convenience. This is different from |remove()|, which removes a certain
  index from a list. {list} is modified in place and returned for convenience.
  Throws ERROR(NotFound) if {item} is not in {list}.

maktaba#list#RemoveDuplicates({list})        *maktaba#list#RemoveDuplicates()*
  Removes duplicates in {list} in-place. {list} is returned for convenience.

maktaba#list#RemoveAll({list}, {item})              *maktaba#list#RemoveAll()*
  Removes all instances of {item} from {list}. {list} is modified in place and
  returned for convenience.

maktaba#log#Logger({context})                           *maktaba#log#Logger()*
  Creates a |maktaba.Logger| interface for {context}.

maktaba#log#AddHandler({handler}, [fire_recent])    *maktaba#log#AddHandler()*
  Registers {handler} to receive log messages. {handler} must refer to a
  function that takes 4 arguments: level (number), timestamp (number), context
  (string), and message (string).

  If [fire_recent] is 1 and messages have already been logged before a handler
  is added, some recent messages may be passed to the handler as soon as it's
  registered. The number of messages stored is controlled by vim's 'history'
  setting.

  This function returns a function which, when applied, unregisters {handler}.
  Hold on to it if you expect you'll need to remove {handler}.
  [fire_recent] is 0 if omitted.

maktaba#path#IsAbsolute({path})                    *maktaba#path#IsAbsolute()*
  Whether {path} is absolute.

maktaba#path#IsRelative({path})                    *maktaba#path#IsRelative()*
  Whether {path} is relative.

maktaba#path#Join({components})                          *maktaba#path#Join()*
  Joins the list {components} together using the system separator character.
  Works like python's os.path.join in that
>
    Join('relative', '/absolute')
<
  is '/absolute'

maktaba#path#Split({path})                              *maktaba#path#Split()*
  Splits {path} on the system separator character.

maktaba#path#Basename({path})                        *maktaba#path#Basename()*
  The basename of {path}. Trailing slash matters. Consider:
>
    :echomsg maktaba#path#Basename('/path/to/file')
    :echomsg maktaba#path#Basename('/path/to/dir/')
<
  The first echoes 'file', the second echoes ''.

maktaba#path#Dirname({path})                          *maktaba#path#Dirname()*
  The dirname of {path}. Trailing slash matters. Consider:
>
    :echomsg maktaba#path#Basename('/path/to/file')
    :echomsg maktaba#path#Basename('/path/to/dir/')
<
  The first echoes '/path/to', the second echoes '/path/to/dir'

maktaba#path#GetDirectory({path})                *maktaba#path#GetDirectory()*
  Gets the directory path of {path}. If {path} appears to point to a file, the
  parent directory will be returned. Otherwise, {path} will be returned. In
  both cases, the returned {path} will have a tailing slash.

maktaba#path#MakeRelative({root}, {path})        *maktaba#path#MakeRelative()*
  Returns a relative path from {root} to {path}. Both paths must be absolute.
  {root} is assumed to be a directory. In windows, both paths must be in the
  same drive.
  Throws ERROR(BadValue) unless both paths are absolute.

maktaba#path#Exists({path})                            *maktaba#path#Exists()*
  Checks whether {path} (a file or directory) exists on the filesystem.

maktaba#path#MakeDirectory({dir})               *maktaba#path#MakeDirectory()*
  Makes {dir}. Returns 0 if {dir} already exists. Returns 1 if {dir} is
  created. This function is similar to |mkdir()| with the 'p' flag, but works
  around a Vim7.3 bug where mkdir chokes on trailing slashes.
  Throws ERROR(BadValue) if {dir} is a file.
  Throws ERROR(NotAuthorized) if {dir} cannot be created.

maktaba#plugin#Enter({file})                          *maktaba#plugin#Enter()*
  This function is used to both control when plugin files are entered, and get
  a handle to the current plugin object. It should be called from the top of
  an autoload/*.vim, plugin/*.vim, ftplugin/*.vim, or instant/*.vim file as
  follows:
>
    let [s:plugin, s:enter] = maktaba#plugin#Enter(expand('<sfile>:p'))
    if !s:enter
      finish
    endif
<
  The result is a tuple containing the plugin object and a boolean specifying
  whether the file should be entered (taking user preferences and whether the
  file has already been sourced into account). If the second value is false,
  the script should finish immediately.

  autoload/*.vim files are entered on demand (see |autoload|), this function
  only helps prevent re-entry.

  For plugin/*.vim and instant/*.vim files, maktaba ensures that the file is
  only entered once, and then only if the user has not disabled the file via
  the plugin[*] or instant[*] flags.

  In ftplugin/*.vim files, maktaba ensures that the file is loaded only once
  per buffer.

  Note that maktaba does NOT set the g:loaded_{plugin} variable, as
  recommended in the write-plugin helpfiles. This is because maktaba plugins
  may span multiple files, and there is no clear moment when the plugin is
  "loaded". If you feel you must adhere to this convention, be sure to set the
  appropriate g:loaded_* variable when appropriate.

maktaba#plugin#Detect()                              *maktaba#plugin#Detect()*
  Scans 'runtimepath' for any unregistered plugins and registers them with
  maktaba. May trigger instant/ hooks for newly-registered plugins.

maktaba#plugin#RegisteredPlugins()        *maktaba#plugin#RegisteredPlugins()*
  A list of all installed plugins in alphabetical order. Automatically detects
  unregistered plugins using |maktaba#plugin#Detect()|.

maktaba#plugin#IsRegistered({plugin})          *maktaba#plugin#IsRegistered()*
  1 if {plugin} was registered with maktaba#plugin#Register. This is more
  reliable for determining if a Maktaba compatible plugin by the name of
  {plugin} was registered, but can not be used to dependency check non-Maktaba
  plugins. Detects plugins added to 'runtimepath' even if they haven't been
  explicitly registered with maktaba.

maktaba#plugin#CanonicalName({plugin})        *maktaba#plugin#CanonicalName()*
  The canonical name of {plugin}. This is the name of the plugin directory
  with any "vim-" prefix or ".vim" suffix stripped off: both "vim-unimpaired"
  and "unimpaired.vim" would become simply "unimpaired".

  Note that plugins with different names in the filesystem can conflict in
  maktaba. If you've loaded a plugin in the directory "plugins/vim-myplugin"
  then maktaba can't handle a plugin named "plugins/myplugin". Make sure your
  plugins have sufficiently different names!

maktaba#plugin#Install({dir}, [settings])           *maktaba#plugin#Install()*
  Installs the plugin located at {dir}. Installation entails adding the plugin
  to the runtimepath, loading its flags.vim file, and sourcing any files in
  its instant/ directory.

  Returns the maktaba plugin object describing the installed plugin.

  {dir} should be the full path to the plugin directory. The plugin itself
  should be the last component in the directory path. If the plugin doesn't
  have an explicit name declared in addon-info.json, the plugin name will be
  the name of this directory with all invalid characters converted to
  underscores (see |maktaba#plugin#CanonicalName()|).

  If the plugin contains a plugin/ directory it will have a special "plugin"
  dictionary flag that controls which plugin files are loaded. For example, if
  the plugin contains plugin/commands.vim, you can use
>
    let plugin = maktaba#plugin#Install(path)
    call plugin.Flag('plugin[commands]', 0)
<
  to disable it. More generally, "plugin" is a dictionary whose keys control
  the loading of plugin files. A file's key is its filename without the '.vim'
  extension. Set the key to 0 to prevent the file from loading or 1 to allow
  it to load.

  Note that setting the key to 1 only ALLOWS the file to load: if load time
  has already passed, enabling the plugin file will not cause it to load. To
  load plugin files late use |Plugin.Load|.

  All plugin files are loaded by default EXCEPT the file plugin/mappings.vim,
  which is opt-in. (Set plugin[mappings] to 1 to enable.)

  If the plugin contains an instant/ directory it will also have a special
  "instant" flag, which acts similarly to the special "plugin" flag for
  instant/*.vim files. For example, in a plugin with an instant/earlyfile.vim,
  the following DOES NOT WORK:
>
    let plugin = maktaba#plugin#Install(path)
    call plugin.Flag('instant[earlyfile]', 0)
<
  All instant/*.vim files are sourced during installation. In order to
  configure the "instant" flag, you must pass [settings] to the installation
  function. If given, they must be a list of maktaba settings (see
  |maktaba#setting#Create|). They will be applied after instant/flags.vim is
  sourced (if present), but before any other instant files are sourced. For
  example:
>
    let noearly = maktaba#setting#Parse('instant[earlyfile]=0')
    let plugin = maktaba#plugin#Install(path, [noearly])
<
  Throws ERROR(BadValue) if {dir} is empty.
  Throws ERROR(AlreadyExists) if the plugin already exists.
  Throws ERROR(ConfigError) if [settings] cannot be applied to this plugin.

maktaba#plugin#Get({plugin})                            *maktaba#plugin#Get()*
  Gets the plugin object associated with {plugin}. {plugin} may either be the
  name of the plugin directory, or the canonicalized plugin name (with any
  "vim-" prefix or ".vim" suffix stripped off). See
  |maktaba#plugin#CanonicalName()|. Detects plugins added to 'runtimepath'
  even if they haven't been explicitly registered with maktaba.
  Throws ERROR(NotFound) if the plugin object does not exist.

maktaba#plugin#GetOrInstall({dir}, [settings]) *maktaba#plugin#GetOrInstall()*
  Installs the plugin located at {dir}, unless it already exists. The
  appropriate maktaba plugin object is returned.

  [settings], if given, must be a list of maktaba settings (see
  |maktaba#setting#Create|). If the plugin is new, they will be applied as in
  |maktaba#plugin#Install()|. Otherwise, they will be applied before returning
  the plugin object.

  See also |maktaba#plugin#Install()|.
  Throws ERROR(AlreadyExists) if the existing plugin comes from a different
  directory.
  Throws ERROR(ConfigError) if [settings] cannot be applied to this plugin.

maktaba#plugin#Source({file}, [optional])            *maktaba#plugin#Source()*
  Sources {file}, which should be a list specifying the location of a file
  from the plugin root. For example, if you want to source
  plugin/commands.vim, call this function on ['plugin', 'commands']. The
  referenced file will be sourced, if it exists. Otherwise, exceptions will be
  thrown, unless you set [optional]. If [optional] exists, this function
  returns whether or not the file was actually sourced.
  [optional] is 0 if omitted.
  Throws ERROR(BadValue) if {file} describes a directory.
  Throws ERROR(NotAuthorized) if {file} cannot be read.
  Throws ERROR(NotFound) if {file} does not describe a plugin file.

maktaba#plugin#HasFlag({flag})                      *maktaba#plugin#HasFlag()*
  Whether or not the plugin has a flag named {flag}.

maktaba#python#ImportModule({plugin}, {name})  *maktaba#python#ImportModule()*
  Imports python module {name} into vim from {plugin}. Checks for {name} in
  the plugin's python/ subdirectory for the named module.
  Throws ERROR(NotFound) if the module or python/ subdirectory wasn't found.

  For example:
>
    call maktaba#python#ImportModule(maktaba#plugin#Get('foo'), 'foo.bar')
    python print foo.bar
<
  will print something like

    <module 'foo.bar' from 'repopath/foo/python/foo/bar.py'
>
<

maktaba#rtp#Split([path])                                *maktaba#rtp#Split()*
  Split a string of comma-separated values into a list of values. Handles
  unescaping the commas. [path] The string to split.
  [path] is |runtimepath| if omitted.

maktaba#rtp#Join({paths})                                 *maktaba#rtp#Join()*
  Joins {paths}, a list of strings, into a comma-separated strings. Handles
  the escaping of commas in {paths}.

maktaba#rtp#Add({path})                                    *maktaba#rtp#Add()*
  Adds {path} to the runtimepath.

  In vanilla vim, the runtime path is sorted as follows:
    1. User's vim files.
    2. System vim files.
    3. System after/ files.
    4. User's after/ files.
  This lets the user run both first and last, which is nice. This function
  puts plugin vim files between 2nd in the list (between 1 and 2), and puts
  plugin after/ files 2nd to last in the list (between 3 and 4). The newest
  plugin that you've installed will be the 2nd thing sourced (after user
  files) and its after directory will be the 2nd to last thing sourced (before
  user files). Thus, plugins stack outwards from the middle, like an onion.

  If {path} is already in the runtimepath, the existing instances will be
  removed and {path} will be re-inserted as described above.

  If you have more than one directory of files that you'd like to run
  before/after all plugins, it is recommended that you add that directory
  after all plugins and/or sort the runtimepath yourself.
  |maktaba#rtp#Split()| and |maktaba#rtp#Join()| may be of some use.

maktaba#rtp#Remove({path})                              *maktaba#rtp#Remove()*
  Removes {path} from the runtimepath.

maktaba#rtp#LeafDirs()                                *maktaba#rtp#LeafDirs()*
  Returns a dictionary of {leaf path} for runtimepath directories that appear
  to be plugins. The key is the name of the leaf directory, the path is the
  precise position of the leaf directory (as given in the runtimepath).

  A leaf directory is the final path component of any runtimepath directory,
  excepting directories named like the following:
    * .vim
    * vimfiles
    * vim\d*
    * runtime
    * after
  which are assumed to be user-, system-, or plugin-owned runtimepath
  components.

  This can be used heuristically to return a dictionary of installed plugins,
  so long as the user has not added non-standard directories to their
  runtimepath. Note however that we can't guarantee that all non-system
  non-user non-after runtimepath components actually correspond to valid
  plugins.

maktaba#rtp#HasLeafDir({leaf})                      *maktaba#rtp#HasLeafDir()*
  Returns 1 if it looks like {leaf} exists on the runtimepath. This is a
  guess, and should not be treated as a guarantee. If you have a directory
  named like {leaf} on your runtimepath, or if {leaf} looks like it's a normal
  vim runtime directory, then this function may return a false
  positive/negative.

maktaba#rtp#Load({dir})                                   *maktaba#rtp#Load()*
  Mimics the normal vim load sequence for {dir}, which will be added to the
  runtimepath if it is not already there. This should be done only on
  directories that were not present for the normal vim load sequence.

  All files in the plugin/ directory will be sourced. After that,
  maktaba#filetype#Cycle will be called if the plugin has installed any new
  filetypes.

  If the plugin is a maktaba plugin, you should use maktaba#plugin#Install
  instead.
  Throws ERROR(NotFound) if {dir} does not exist.
  Throws ERROR(BadValue) if {dir} does not describe a directory.

maktaba#rtp#DirDefinesFiletypes({dir})     *maktaba#rtp#DirDefinesFiletypes()*
  Whether or not runtimepath directory {dir} defines a new filetype.

maktaba#setting#ParseHandle({text})            *maktaba#setting#ParseHandle()*
  Parses a flag handle off of {text}, returns a tuple containing [flagname,
  foci, leftover]. See |maktaba#setting#Handle()|; the only difference is that
  this function returns the leftover text after parsing instead of requiring
  that {text} exactly describe a flag handle.

maktaba#setting#Handle({handle})                    *maktaba#setting#Handle()*
  Parses {handle} into a tuple [flagname, foci] where foci is a list of
  numbers and strings. An example may make this clear:
>
    :echomsg maktaba#setting#Handle('flag')
    ~ ['flag', []]
    :echomsg maktaba#setting#Handle('flag[list][3][val]')
    ~ ['flag', ['list', 3, 'val']]
<
  More specifically, this parses a flag name and a series of foci in square
  brackets. A flag name may contain alphanumeric characters and underscores.
  Flag names may also contain, BUT NOT END WITH, the following charcaters:
  . / : #

  Foci are kept in square brackets. They are not allowed to contain square
  brackets. They should describe either dictionary keys or list indicies.

  You're encouraged to use this function when you're exposing complex flags to
  users. Flag handles are part of the maktaba setting syntax. See
  |maktaba#setting#Create()| for more.
  Throws ERROR(BadValue) if {handle} is invalid.

maktaba#setting#Parse({text})                        *maktaba#setting#Parse()*
  Parses a setting from {text}. Returns a tuple [setting, leftover] containing
  first the parsed setting object and second the remaining text. See
  |maktaba#setting#Create()| for details, the only difference is that this
  function returns the leftover text rather than requiring that the text
  exactly specify a setting. The setting must either be the whole string, or
  must be followed by whitespace. The leftover string will be returned with
  leading whitespace stripped, so that the leftover result is suitable for
  another parse immediately.
  Throws ERROR(BadValue) if {text} has invalid syntax.

maktaba#setting#Create({text})                      *maktaba#setting#Create()*
  Creates a maktaba setting from {text}.
  Throws ERROR(BadValue) if {text} has invalid syntax.

maktaba#setting#ParseAll({text})                  *maktaba#setting#ParseAll()*
  Parses a list of settings from {text}. Settings must be separated by spaces
  or tabs. This is the same as repeating |maktaba#setting#Parse()| until
  {text} is empty.
  Throws ERROR(BadValue) if {text} does not describe valid settings.

maktaba#string#Strip({string}, [chars])               *maktaba#string#Strip()*
  Returns {string} stripped of [chars] from both ends. [chars] should be a
  string of characters. THE ORDER OF [chars] DOES NOT MATTER: stripping will
  continue so long as the prefix/suffix contains one of [chars]. For example:
>
    maktaba#string#Strip('0xDEADBEEF', "ABCDEF") == '0x'
<
  [chars] is " \t\n\r" if omitted.

maktaba#string#StripLeading({string}, [chars]) *maktaba#string#StripLeading()*
  Returns {string} stripped of [chars] (a string of characters) from the
  front. THE ORDER OF [chars] DOES NOT MATTER: stripping will continue so long
  as the prefix contains one of [chars]. See also |maktaba#string#Strip()|.
  [chars] is " \t\n\r" if omitted.

maktaba#string#StripTrailing({string}, [chars])
                                              *maktaba#string#StripTrailing()*
  Returns {string} stripped of [chars] (a string of characters) from the end.
  THE ORDER OF [chars] DOES NOT MATTER: stripping will continue so long as the
  suffix contains one of [chars]. See also |maktaba#string#Strip()|.
  [chars] is " \t\n\r" if omitted.

maktaba#string#StartsWith({string}, {prefix})    *maktaba#string#StartsWith()*
  Whether or not {string} starts with {prefix}.

maktaba#string#EndsWith({string}, {suffix})        *maktaba#string#EndsWith()*
  Whether or not {string} ends with {suffix}.

maktaba#syscall#Create({cmd})                       *maktaba#syscall#Create()*
  Creates a |maktaba.Syscall| object that can be used to execute {cmd} with
  |Syscall.Call()|. {cmd} may be a pre-escaped string, a list of words to be
  automatically escaped and joined. Also accepts an existing Syscall object
  and returns it for convenience.
  Throws ERROR(WrongType)

maktaba#test#Override({target}, {replacement})       *maktaba#test#Override()*
  Overides the function {target} such that when it is called, {replacement} is
  called instead. This is particularly useful for overloading autoloaded
  functions, which can only be done in files that are named correctly.
  (name#spaced#Function must be defined in .../name/spaced.vim).

  You can de-override the function via the 'runtime' command, for example:
>
    runtime autoload/name/spaced.vim
<
  will source the original name/spaced.vim, clobbering the overridden
  function.

  Due to vim's naming limitations, this function must make (and source) an
  adequately named temporary file. As such, {replacement} MUST be a string,
  funcref, or funcdict usable from any given scope (i.e., not script-local).

maktaba#user#Name()                                      *maktaba#user#Name()*
  Gets the user's name.

maktaba#user#CacheDir()                              *maktaba#user#CacheDir()*
  Gets a directory that can be used for cache files. Respects $XDG_CACHE_HOME
  if present.

maktaba#user#DataDir()                                *maktaba#user#DataDir()*
  Gets a directory that can be used for data files. Respects $XDG_DATA_HOME if
  present.

maktaba#user#ConfigDir()                            *maktaba#user#ConfigDir()*
  Gets a directory that can be used for config files. Respects
  $XDG_CONFIG_HOME if present.
  Throws ERROR(NotAuthorized) if the directory does not exist and cannot be
  created.

maktaba#value#IsEqual({a}, {b})                      *maktaba#value#IsEqual()*
  Tests whether values {a} and {b} are equal. This works around a number of
  limitations in vimscript's == operator. Unlike with the == operator,
    1. String comparisons are case sensitive.
    2. {a} and {b} must be of the same type: 0 does not equal '0'.
    3. 0 == [] is false (instead of throwing an exception).
  The == operator is insane. Use this instead.

  NOTE: {a} AND {b} MUST BE OF THE SAME TYPE. 1.0 DOES NOT EQUAL 1! This is
  consistent with the behavior of equality established by instant() and
  count(), but may be surprising to some users.

maktaba#value#IsIn({value}, {list})                     *maktaba#value#IsIn()*
  Whether {value} is in {list}.

maktaba#value#EmptyValue({value})                 *maktaba#value#EmptyValue()*
  Returns the empty value for {value}. This is 0, 0.0, '', [], {}, or 'empty',
  depending upon the value type.

maktaba#value#TypeName({value})                     *maktaba#value#TypeName()*
  Returns the type of {value} as a string. One of "number", "string",
  "funcref", "list", "dictionary", or "float". See also |type()|.

maktaba#value#TypeMatches({value}, {reference})  *maktaba#value#TypeMatches()*
  1 if {value} has the same type as {reference}, 0 otherwise.

maktaba#value#TypeMatchesOneOf({value}, {references})
                                            *maktaba#value#TypeMatchesOneOf()*
  1 if {value} has the same type as one of the elements in {references}. 0
  otherwise.

maktaba#value#IsNumber({value})                     *maktaba#value#IsNumber()*
  1 if {value} is a vimscript "number" (more commonly known as "integer", 0
  otherwise. Remember that vimscript calls integers "numbers".

maktaba#value#IsString({value})                     *maktaba#value#IsString()*
  1 if {value} is a string, 0 otherwise.

maktaba#value#IsFuncref({value})                   *maktaba#value#IsFuncref()*
  1 if {value} is a funcref, 0 otherwise.

maktaba#value#IsList({value})                         *maktaba#value#IsList()*
  1 if {value} is a list, 0 otherwise.

maktaba#value#IsDict({value})                         *maktaba#value#IsDict()*
  1 if {value} is a dict, 0 otherwise.

maktaba#value#IsFloat({value})                       *maktaba#value#IsFloat()*
  1 if {value} is a floating point number, 0 otherwise.

maktaba#value#IsNumeric({value})                   *maktaba#value#IsNumeric()*
  1 if {value} is numeric (integer or float, which vimscript stupidly refers
  to as "number" and "float"). 0 otherwise.

maktaba#value#IsCollection({value})             *maktaba#value#IsCollection()*
  1 if {value} is a collection type (list or dict). 0 otherwise.

maktaba#value#IsCallable({value})                 *maktaba#value#IsCallable()*
  1 if {value} is a callable type (string or function), 0 otherwise. This DOES
  NOT guarantee that the function indicated by {value} actually exists.

maktaba#value#IsEnum({value})                         *maktaba#value#IsEnum()*
  1 if {value} is a maktaba enum type, 0 otherwise.

maktaba#value#Focus({target}, {foci}, [value])         *maktaba#value#Focus()*
  Focuses on a part of {target} specified by {foci}. That object will either
  be returned, or set to [value] if [value] is given (in which case {target}
  is returned). Examples will make this clearer:
>
    maktaba#value#Focus({'a': [0, {'b': 'hi!'}, 1]}, ['a', 1, 'b']) == 'hi'
<
  Notice how this function lets you focus on one part of a complex data
  structure. You can also use it to modify the data structure:
>
    maktaba#value#Focus({'a': {'b': 0}}, ['a', 'b'], 2) == {'a': {'b': 2}}
<
  The only real reason to use this code is because it destructures {target} in
  a safe way, throwing exceptions if the implicit assumptions aren't met.
  Throws ERROR(BadValue) if {target} cannot be deconstructed the way {foci}
  expects.

maktaba#value#Save({variable})                          *maktaba#value#Save()*
  Captures the state of a {variable} into a returned dict. The return value
  can be passed to |maktaba#value#Restore()| to restore the listed variable to
  its captured state.
  Throws ERROR(WrongType)
  Throws ERROR(BadValue)

maktaba#value#SaveAll({variables})                   *maktaba#value#SaveAll()*
  Captures the state of a list of {variables} into a returned dict. The return
  value can be passed to |maktaba#value#Restore()| to restore all listed
  variables to their captured state.
  Throws ERROR(WrongType)
  Throws ERROR(BadValue)

maktaba#value#Restore({state})                       *maktaba#value#Restore()*
  Restores the previously-captured {state} of the set of variables. {state} is
  a dict returned from a previous call to |maktaba#value#Save()| or
  |maktaba#value#SaveAll()|.
  Throws ERROR(WrongType)
  Throws ERROR(BadValue)

==============================================================================
ERROR HANDLING                                            *maktaba-exceptions*

Maktaba provides utilities for error handling in vim. Unfortunately, error
handling in vim is insane. The "catch" command takes a regex that matches the
error message. You should always match an error code, because the message
itself can be locale dependant. Vim's error codes are opaque and poorly
documented.

To make matters worse, you can't define error codes as variables and catch
them, because
>
  catch g:MY_ERROR_CODE
<
tries to match the literal characters 'g:MY_ERROR_CODE', not the result of the
variable. And you can't use
>
  execute 'catch' g:MY_ERROR_CODE
<
because execute runs WITHIN the context of the try block -- |:execute|d catch
are completely ignored.

And just to keep things interesting, your catch statements had better not use
the ^ atom, because the error code isn't always at the beginning of the
exception text. Vim may tack other context data at the beginning. The best you
can do is something like this:
>
  " Function not found.
  catch /E117:/
<

and hope that normal error text doesn't contain things that look like error
codes. Vimscript doesn't allow us much in the way of error safety: the best we
can do is establish a convention and play make-believe. The convention is as
follows:

  1. Use error names (CamelCased short versions of the error type) instead of
    opaque error codes. This makes your code more readable.
  2. Wrap error codes in ERROR() instead of E...: This differentiates custom
    errors from vim errors and has the pleasant side effect of tricking the
    vim syntax highlighting into thinking we know what we're doing.

Example:
>
  ERROR(NotFound): File "your/file" not found.
<

Below you'll find helper functions for generating such error messages. With
any luck, this will help you avoid a few typos.

                                                        *ERROR(NotAuthorized)*
For when someone tries to do something they shouldn't.

                                                             *ERROR(NotFound)*
For when someone expected something to be there, and it wasn't.

                                                       *ERROR(NotImplemented)*
For attempts to use functionality that is not yet supported.

                                                            *ERROR(WrongType)*
For when someone tried to use the wrong type of arguments.

                                                             *ERROR(BadValue)*
For when someone tried to use insane values.

                                                     *ERROR(InvalidArguments)*
For when a function is given the wrong number of arguments. Prefer
|ERROR(WrongType)| and |ERROR(BadValue)| when relevant.

                                                       *ERROR(MissingFeature)*
For use when a |has()| check fails.

                                                              *ERROR(Failure)*
For use in code that should never be reached.


vim:tw=78:ts=8:ft=help:norl:
